## 영속성 어댑터 구현하기

헥사고날 아키텍처에서 영속성 어댑터는 '주도되는' 혹은 '아웃고잉' 어댑터라고 부른다. 애플리케이션에 의해 호출될 뿐,

애플리케이션을 호출하지 않기 때문이당.

아웃고잉 포트를 두고 어댑터를 구현하는 이유는 영속성 계층에 대한 코드 의존성을 없애기 위함이다.

## 영속성 어댑터의 책임

```
입력을 받는다

입력을 데이터베이스 포맷으로 매핑

입력을 데이터베이스로 보낸다

데이터베이스 출력을 애플리케이션 포맷으로 매핑한다

출력을 반환한다.
```

영속성 어댑터의 입력, 출력 모델은 어플리케이션 코어에 위치해야 한다. 영속성 어댑터 내부를 변경하는 것이

코어에 영향을 미치면 안 된다! account-adapter-out-persistence 참고


## 포트 인터페이스 나누기

ISP - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다

단일 아웃 고잉 포트 인터페이스를 두어 서비스에서 사용하는 메서드를 모두 구현하게 되면 응용 서비스는 

클라이언트 서비스가 불필요한 코드를 의존하게 된다. 

응용 서비스는 필요한 아웃 고잉 포트 인터페이스만 알고 있으면 된다. 

보통의 경우 포트 하나당 하나의 메서드를 구현하지만 그렇지 못할수도 있다. 

중요한 것은 인터페이스를 여러개로 나누고 포트의 이름을 역할에 따라 명확하게 함으로써 유지 보수성을 높일 수 있다는 것이다.

SendMoneyService 참고 


## 영속성 어댑터 나누기

영속성 어댑터는 하나 또는 여러 개의 아웃고잉 포트 인터페이스를 기반으로 구현하고 필드 값으로 데이터 접근 기술을 

주입받아서 사용한다 AccountPersistenceAdapter 참고

애그리거트 당 하나의 어댑터를 가지면 바운디드 컨텍스트별로 구별하기 용이해지며 

도메인, DDD 애그리거트는 하나의 영속성 어댑터를 가질 수도 있고 하나 이상 가질 수도 있다.

ex) JPA 나 OR 매퍼를 이용한 영속성 포트를 구현한 어댑터 and 평범한 SQL 을 이용하는 포트를 구현한 어댑터  


## 스프링 데이터 JPA 예제

AccountPersistenceAdapter 는 계좌를 가져오는 포트와 계좌를 업데이트하는 포트를 기반으로 구현되었다. (클래스 참고)

필드 값으로 계좌, 계좌 활동 저장소를 스프링 데이터 JPA 로 주입 받았고, 요청 값을 반환할 때 사용할 계좌 매퍼가 있다.

예제는 항상 데이터의 일부만 가져오기를 요구하기 때문에 매핑하지 않기 전략을 사용

```
> 간단한 매핑하지 않기 전략 설명 < 

응용 서비스에서 어댑터의 loadAccount 로직을 수행할 때 계좌 아이디와 기준 시간을 변수로 받는다.

계좌 저장소에서 계좌 아이디 값으로 계좌를 찾고 요구사항에 따라 일정 기간 동안의 거래내역을 가져온다.

계좌, 계좌 활동 내역, 거래 내역으로 엔티티 매퍼를 호출한다.

이때 도메인 로직을 호출하기 전 엔티티 매퍼에서 기준 금액과 사용한 금액으로 기준 금액을 맞추고 

계좌 도메인 withId 메서드를 호출, 계좌 클래스를 만들어서 반환하면 필요한 곳에서 사용된다.
```

매핑하지 않기 전략도 유효한 전략으로 사용할 수 있다.

매핑하지 않기 전략을 사용한 이유는 데이터의 일부만 가져와서 보여주기 위함, 풍부한 도메인 모델을 사용하고 싶다면

도메인 모델과 영속성 모델을 매핑하면 된다. 77p

## 데이터베이스 트랜잭션은 어디서 시작해야 할까?

응용 서비스에서 시작한다.
