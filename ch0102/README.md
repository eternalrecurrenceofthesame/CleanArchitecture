## 계층형 아키텍처의 문제는 무엇일까?

웹 -> 도메인(서비스 + 비즈니스 로직) -> 영속성(엔티티 <- 리포지토리)  // 계층형 아키텍처. 4p 그림

엔티티 클래스가 영속성 계층이라는 의미. 

***근데 이런 구조는 한번도 안 만들어봄..***

* 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

계층형 아키텍처는 영속성 계층을 토대로 웹과 도메인이 만들어진다. 도메인은 비즈니스 요구사항에 따라 만들어져야지 데이터베이스를 토대로 만들면 안 된다.

비즈니스 요구사항에 따른 도메인을 먼저 만들자!

* 지름길을 택하기 쉬워진다

상위 계층에 위치한 컴포넌트에 접근해야 하는 경우 상위 계층을 하위 계층으로 내려서 사용해버린다 (어플리케이션 응집성이 떨어짐)

* 테스트하기 어려워진다 (계층을 건너뛰는 경우).

웹 계층에서 도메인(서비스) 을 건너 뛰고 엔티티에 바로 접근하는 경우 도메인 로직을 웹 계층에 구현할 수 있고 테스트 코드 작성시

웹 계층 테스트시 영속성 계층을 모킹해서 주입받아야하기 때문에 테스트의 복잡성이 올라간다.

* 유스케이스를 숨긴다

기능이 추가되거나 변경된다면 적절한 위치에 맞게 변경해야 한다 하지만 계층형 아키텍처를 사용하면 도메인 로직이 여러 계층에

걸쳐 흩어지기가 쉽다. 유스케이스가 간단해서 도메인 계층을 생략해버리면 웹 계층이나 영속성 계층에 도메인 로직이 흩어질 수 있다.

* 동시 작업이 어려워진다

계층형 아키텍처는 영속성 계층을 토대로 탑이 쌓이기 때문에 웹과 도메인이 동시에 작업할 수 없다.

## 의존성 역전하기

#### + 단일 책임 원칙 SRP
```
컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

컴포넌트가 다른 컴포넌트들에 의존하고 있다면 다른 컴포넌트들이 변경되면 그 녀석들로 인해서 변경될 수 있다. 14p

하지만 컴포넌트가 다른 컴포넌트들에 의존하지 않는 다면 변경 이유는 그 컴포넌트에 새로운 요구 사항이 추가되어 

기능이 변경될 때 말고는 없다.
```

#### ++ 개방 페쇄 원칙 OCP
```
소프트웨어는 확장에는 열려 있어야 하며 변경에는 닫혀 있어야 한다.

다형성의 활용.
```

#### +++ 의존성 역천 원칙 DIP
```
코드상의 어떤 의존성이든 그 방향을 바꿀 수 (역전시킬 수) 있다.

도메인 요구사항을 토대로 도메인을 만든 다음 도메인을 토대로 리포지토리 인터페이스를 만들면 (DDD)

인프라 계층의 리포지토리 구현체는 도메인 인터페이스에 의존해서 구현되기 때문에 구현체를 갈아 끼우기(역전)만 하면 된다.

이때 스프링 의존관계 주입 DI 를 활용해서 구현체를 주입 받으면 다형성을 지키면서 OCP + DIP 를 지킬 수 있다.
```


