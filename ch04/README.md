## 도메인 모델 구현하기

한 계좌에서 다른 계좌로 송금하는 유스케이스 만들기, 엔티티를 만드는 것 부터 시작해서 해당 도메인 엔티티 중심 유스케이스 구현

* buckpal-account-domain 패키지 참고 

```
Account(계좌)

계좌 클래스는 기준 금액과 최근 활동 내역을 가지고 비즈니스 규칙으로 출금과 예금을 구현한다. 

Activity(거래), ActivityWindow(거래 내역)

거래 클래스는 말 그대로 계좌로 거래를 만드는 클래스, 계좌는 거래 내역 클래스를 필드값으로 가지고 일정 기간 

동안의 거래 내역을 가진다. 한 계좌에 대한 모든 거래를 즉시 메모리에 올리는 것은 현명한 방법이 아니다. 35p

그렇기 때문에 거래 클래스를 만들고 거래 내역을 계좌에 필드값으로 저장해둔다. 

ActivityWindow(거래 내역) 의 비즈니스 규칙으로 예금액을 계산하는 메서드를 만들었다. 이 메서드는 계좌의 기본 금액에

활동한 내역을 종합해서 baselineBalance(기준 금액) 에 반영한다.

```

유스케이스는 인커밍 어댑터로부터 입력을 받는다. 이때 입력의 유효성 검사를 유스케이스에서 하지 않는다

유스케이스는 엔티티와 함께 도메인 비즈니스 규칙을 검증하는데 집중해야 한다. 

입력 값을 기반으로 모델의 상태를 변경하고 영속성 포트를 통해 값을 저장하고 다른 어댑터를 호출할 수 있으며,

리턴 받은 출력 값을 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환한다. 


Tip **모든 유스케이스를 한 서비스 클래스에 넣지 않고 각각 만들어야 넓은 서비스 문제를 피할 수 있다 (유지보수)**

* buckpal-account-application
```
SendMoneyService 는 인커밍 포트 인터페이스인 SendMoneyUseCase 를 구현하고, SendMoneyCommand 를 받는다.

그리고 아웃 고잉 포트인 LoadAccountPort 를 통해 domain-Account 객체를 불러오고 UpdateAccountPort 를 이용해서

계좌 상태를 업데이트한다.

```
application 계층은 입력 값이 들어올 때 유효성 검사를 해서 도메인 모델의 상태를 보호해야 한다.  

앞서 말했지만 유효성 검사는 유스케이스에서 하지 않는다. 유효성 검사는 입력 모델 SendMoneyCommand 에서 한다.

