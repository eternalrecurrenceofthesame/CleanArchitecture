## 도메인 모델 구현하기

한 계좌에서 다른 계좌로 송금하는 유스케이스 만들기, 엔티티를 만드는 것 부터 시작해서 해당 도메인 엔티티 중심 유스케이스 구현

* buckpal-account-domain 패키지 참고 

```
Account(계좌)

계좌 클래스는 기준 금액과 최근 활동 내역을 가지고 비즈니스 규칙으로 출금과 예금을 구현한다. 

Activity(거래), ActivityWindow(거래 내역)

거래 클래스는 말 그대로 계좌로 거래를 만드는 클래스, 계좌는 거래 내역 클래스를 필드값으로 가지고 일정 기간 

동안의 거래 내역을 가진다. 한 계좌에 대한 모든 거래를 즉시 메모리에 올리는 것은 현명한 방법이 아니다. 35p

그렇기 때문에 거래 클래스를 만들고 거래 내역을 계좌에 필드값으로 저장해둔다. 

ActivityWindow(거래 내역) 의 비즈니스 규칙으로 예금액을 계산하는 메서드를 만들었다. 이 메서드는 계좌의 기본 금액에

활동한 내역을 종합해서 baselineBalance(기준 금액) 에 반영한다.

```

유스케이스는 인커밍 어댑터로부터 입력을 받는다. 이때 입력의 유효성 검사를 유스케이스에서 하지 않는다

유스케이스는 엔티티와 함께 도메인 비즈니스 규칙을 검증하는데 집중해야 한다. 

입력 값을 기반으로 모델의 상태를 변경하고 영속성 포트를 통해 값을 저장하고 다른 어댑터를 호출할 수 있으며,

리턴 받은 출력 값을 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환한다. 


Tip **모든 유스케이스를 한 서비스 클래스에 넣지 않고 각각 만들어야 넓은 서비스 문제를 피할 수 있다 (유지보수)**

## 유스케이스 구현하기

* buckpal-account-application
```
SendMoneyService 는 인커밍 포트 인터페이스인 SendMoneyUseCase 를 구현하고, SendMoneyCommand (입력 모델) 를 받는다.

그리고 아웃 고잉 포트인 LoadAccountPort 를 통해 domain-Account 객체를 불러오고 UpdateAccountPort 를 이용해서

계좌 상태를 업데이트한다.

```
application 계층은 입력 값이 들어올 때 유효성 검사를 해서 도메인 모델의 상태를 보호해야 한다.  

앞서 말했지만 유효성 검사는 유스케이스에서 하지 않는다. 유효성 검사는 입력 모델 SendMoneyCommand (입력 모델) 의 생성자 내에서 한다.

값을 생성할 때 유효성 체크를 하고 final 필드로 만들어서 생성에 성공하고 난 이후 불변 상태를 보장한다.

입력 모델은 유스케이스 API 의 일부기 때문에 인커밍 포트 패키지에 위치해서 어플리케이션 코어에 남아있지만 

유스케이스를 오염시키지 않는다. SendMoneyCommand 참고 

빌더 대신 생성자를 사용해서 얻을 수 있는 이점도 있다. 43p

#### + 각 유스케이스는 다른 입력 모델을 가져야 한다.

계좌 등록과 계좌 업데이트가 비슷하다고해서 같은 모델을 사용하면 등록할 때 아이디값이 null 인 불변 객체로 만들어진다

불변 커맨드 객체의 필드에 대해서 null 을 유요한 상태로 받아들이는 것 자체로 code smell 상태가 될 수 있다.

또한 유효성 검증도 서로 다른 로직이 필요하다 

계좌 등록하기 유스케이스를 호출할 때 아이디 값이 들어간다면? 이런 사이드 이펙트를 처리하는 부분까지 생각해야하기 떄문에

유지보수가 힘들어지고 응집성이 떨어지기 때문에 다른 입력 모델을 가지도록하자! 글만 봐도 복잡하다!


## 비즈니스 규칙 검증하기

입력 유효성 검증은 유스케이스 로직의 일부가 아닌 반면, 비즈니스 규칙 검증은 유스케이스 로직의 일부이다. 

언제 입력 유효성을 검증하고 언제 비즈니스 규칙을 검증해야 할까?

>입력 유효성을 검증하는 것은 **구문상의 (syntactical)** 유효성 검증
>
>비즈니스 규칙의 검증은 맥락속의 **의미적인 (semantical)** 유효성  검증

```
"출금 계좌는 초과 출금되어서는 안된다" 
    <- 출금 계좌와 입금 계좌가 존재하는지 확인하기 위해 모델의 현재 상태에 접근해야 하므로 비즈니스 규칙이 된다.
 
 "송금 되는 금액은 0 보다 커야 한다"
    <- 모델에 접근하지 않고 Command 에서 검증할 수 있으므로 입력 유효성 검증으로 구현한다. 
```

주관적인 것 같지만 앞서 구분한 것처럼 인커밍 포트에서 커맨드를 받을 때 입력 유효성을 검증해서

유스케이스를 오염시키지 않는다 / 구문과 의미로 제약 조건을 결정하면 체계적으로 규칙을 적용할 수 있다 46p

그리고 비즈니스 규칙은 도메인 엔티티 안에 넣는 것이 좋다.

```
public class Account {  // 계좌 클래스 참고 

// 비즈니스 규칙 
public boolean withdraw(Money money, AccountId targetAccountId){
if(!mayWithdraw(money)){ //비즈니스 규칙 검증 메서드 
return false;
}
}
}
```
비즈니스 규칙 바로 옆에 검증 조건을 두어서 응집성을 높일 수 있다!

엔티티에서 비즈니스 규칙을 검증하기 힘들다면 유스케이스에서 도메인 엔티티를 사용하기 전에 해도 된다.
```
AccountId sourceAccountId
                = sourceAccount.getId().orElseThrow(() -> new IllegalArgumentException());
AccountId targetAccountId
                = targetAccount.getId().orElseThrow(() -> new IllegalArgumentException()); // 검증 전용 예외 던지기 
                
  커멘드로 값을 찾고 loadAccountPort 로 계좌를 불러와서 값이 없으면 예외가 터지는 로직 SendMoneyService 참고  
  
  예외를 사용자에게 보여주거나 다른 방법으로 처리! 
```

정리하자면 복잡한 비즈니스 로직의 경우 유스케이스에서 도메인 엔티티를 로드해서 비즈니스 규칙을 검증할 수도 있지만

도메인 모델을 로드해야 한다면 도메인 엔티티 내에 비즈니스 규칙을 구현해야 한다.


####  ++ 유스케이스마다 다른 출력 모델 반환

SendMoneyService 유스 케이스에서 출력 값으로 true 만 반환한다. 출력 값은 구체적이고 꼭 필요한 최소한의 데이터만 있어야 한다.

유스케이스마다 같은 출력 모델을 공유하게 되면 유스케이스들이 강하게 결합된다. 각각의 유스케이스에서 필요한 값이 더해질 때 마다

모델에 관련없는 값들이 추가되기 때문에 유지보수가 어려워진다.

유스케이스를 가능한 한 구체적으로 유지하기 위해 출력 값이 정말 필요한 데이터인지 항상 고민하자.

#### +++ CQRS 패턴을 이용한 읽기 전용 유스케이스 

상태를 변경하는 범위와 데이터를 조회하는 범위는 일치하지 않기 때문에 이 둘을 단일 모델로 만들면 불필요하게 복잡해진다.

조회와 명령을 분리해서 조회에 최적화된 기능을 제공하자.

GetAccountBalanceService 참고 





